// Math Learning App - Fixed Version
class MathApp {
  constructor() {
    console.log('üéì MathApp constructor called');
    
    // In-memory data storage (localStorage simulation blocked in sandbox)
    this.storageData = {
      mathApp_userData: null,
      mathApp_settings: null,
      mathApp_version: '1.0'
    };
    
    // Initialize core properties with proper validation
    this.users = [];
    this.currentUser = null;
    this.currentLanguage = 'he';
    
    // Data persistence configuration
    this.saveDebounceMs = 1000;
    this.saveTimeout = null;
    
    // Language and translation data
    this.languages = {
      en: { code: "en", name: "English", flag: "üá∫üá∏", direction: "ltr" },
      ru: { code: "ru", name: "–†—É—Å—Å–∫–∏–π", flag: "üá∑üá∫", direction: "ltr" },
      he: { code: "he", name: "◊¢◊ë◊®◊ô◊™", flag: "üáÆüá±", direction: "rtl" }
    };
    
    // Difficulty levels configuration
    this.difficultyLevels = {
      easy: {
        level: 1,
        color: "#4CAF50",
        stars: 1,
        icon: "‚≠ê",
        multiplication: { min_factor1: 1, max_factor1: 5, min_factor2: 1, max_factor2: 5 },
        subtraction: { min_minuend: 5, max_minuend: 20, min_subtrahend: 1, max_subtrahend: 10 },
        division: { dividends: [2, 4, 6, 8, 10, 12, 15, 16, 18, 20], divisors: [1, 2, 3, 4, 5] },
        addition: { min_addend1: 1, max_addend1: 9, min_addend2: 1, max_addend2: 9 }
      },
      medium: {
        level: 2,
        color: "#FF9800",
        stars: 2,
        icon: "‚≠ê‚≠ê",
        multiplication: { min_factor1: 1, max_factor1: 10, min_factor2: 1, max_factor2: 10 },
        subtraction: { min_minuend: 10, max_minuend: 50, min_subtrahend: 1, max_subtrahend: 25 },
        division: { min_dividend: 1, max_dividend: 100, min_divisor: 1, max_divisor: 10 },
        addition: { min_addend1: 10, max_addend1: 89, min_addend2: 5, max_addend2: 49 }
      },
      hard: {
        level: 3,
        color: "#F44336",
        stars: 3,
        icon: "‚≠ê‚≠ê‚≠ê",
        multiplication: { min_factor1: 10, max_factor1: 999, min_factor2: 10, max_factor2: 99 },
        subtraction: { min_minuend: 100, max_minuend: 9999, min_subtrahend: 50, max_subtrahend: 999 },
        division: { min_quotient: 10, max_quotient: 200, min_divisor: 12, max_divisor: 99 },
        addition: { min_addend1: 100, max_addend1: 999, min_addend2: 50, max_addend2: 999 }
      }
    };
    
    // Pre-generated hard division problems to ensure exact results
    this.hardDivisionProblems = [
      [1024, 16, 64], [1488, 24, 62], [2304, 48, 48], [1764, 36, 49], [936, 12, 78],
      [1680, 35, 48], [2016, 42, 48], [1890, 27, 70], [2112, 33, 64], [1560, 26, 60],
      [2088, 29, 72], [1944, 54, 36], [2352, 56, 42], [1728, 32, 54], [2280, 38, 60],
      [1650, 25, 66], [2268, 63, 36], [1800, 45, 40], [2016, 28, 72], [1512, 21, 72],
      [2340, 39, 60], [1872, 52, 36], [2205, 45, 49], [1596, 28, 57], [2080, 65, 32],
      [1755, 39, 45], [2108, 44, 47], [1848, 33, 56], [2275, 35, 65], [1632, 24, 68]
    ];
    
    this.currentDifficulty = 'easy';
    
    this.translations = {
      en: {
        app_title: "üéì Math Adventure! üéì",
        welcome: "Choose your profile or create a new one!",
        create_user: "Create New User",
        select_user: "Select User",
        enter_name: "Enter your name",
        start_learning: "Start Learning!",
        multiplication: "Multiplication",
        subtraction: "Subtraction",
        division: "Division",
        addition: "Addition",
        start_exercise: "Start Exercise",
        daily_progress: "Today's Progress",
        success_rate: "Success Rate",
        current_streak: "Current Streak",
        choose_exercise: "Choose Your Exercise",
        your_achievements: "Your Achievements",
        view_progress: "View Detailed Progress",
        your_score: "Your Score",
        settings: "Settings",
        language: "Language",
        switch_user: "Switch User",
        download_app: "Download App",
        back: "‚Üê Back",
        next: "Next",
        finish: "Finish",
        solve_problem: "Solve the problem:",
        solve_addition_problem: "Solve the addition problem:",
        enter_answer: "Your answer",
        submit: "Submit",
        correct: "Correct!",
        incorrect: "Try again!",
        great_job: "Great job!",
        excellent_work: "Excellent Work!",
        correct_answers: "Correct",
        incorrect_answers: "Incorrect",
        try_again: "Try Again",
        different_exercise: "Try Different Exercise",
        back_to_dashboard: "Back to Dashboard",
        your_progress: "Your Progress",
        overall_stats: "Overall Statistics",
        total_exercises: "Total Exercises",
        total_correct: "Total Correct",
        best_streak: "Best Streak",
        days_practiced: "Days Practiced",
        exercise_breakdown: "Exercise Type Breakdown",
        exercises_completed: "exercises completed",
        completed_all: "You've completed all",
        exercises_for_today: "exercises for today! Try a different type.",
        difficulty: "Difficulty",
        difficulty_easy: "Easy",
        difficulty_medium: "Medium",
        difficulty_hard: "Hard",
        difficulty_description_easy: "Perfect for beginners! Simple single-digit problems.",
        difficulty_description_medium: "Great for students with some experience.",
        difficulty_description_hard: "Advanced multi-digit problems for math experts!",
        expert_level: "Expert Level Problems!",
        multi_digit_warning: "Get ready for multi-digit challenges!",
        good_job_easy: "Great start! You're learning fast!",
        good_job_medium: "Excellent work! You're getting stronger!",
        good_job_hard: "Amazing! You're tackling expert-level math!",
        select_difficulty: "Select Difficulty Level",
        change_difficulty: "Change Difficulty",
        current_difficulty: "Current Level",
        completed_on: "Completed on",
        mastered: "Mastered!",
        try_harder: "Ready for a challenge? Try the next level!",
        good_job_easy: "Great start! You're learning fast!",
        good_job_medium: "Excellent work! You're getting stronger!",
        good_job_hard: "Amazing! You're a math champion!",
        great_addition_skills: "Great addition skills!",
        addition_master: "Addition Master!"
      },
      ru: {
        app_title: "üéì –ò–∑—É—á–µ–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏! üéì",
        welcome: "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π!",
        create_user: "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        select_user: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        enter_name: "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è",
        start_learning: "–ù–∞—á–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ!",
        multiplication: "–£–º–Ω–æ–∂–µ–Ω–∏–µ",
        subtraction: "–í—ã—á–∏—Ç–∞–Ω–∏–µ",
        division: "–î–µ–ª–µ–Ω–∏–µ",
        addition: "–°–ª–æ–∂–µ–Ω–∏–µ",
        start_exercise: "–ù–∞—á–∞—Ç—å —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ",
        daily_progress: "–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å",
        success_rate: "–ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞",
        current_streak: "–¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è",
        choose_exercise: "–í—ã–±–µ—Ä–∏—Ç–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ",
        your_achievements: "–í–∞—à–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è",
        view_progress: "–ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞",
        your_score: "–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç",
        settings: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        language: "–Ø–∑—ã–∫",
        switch_user: "–°–º–µ–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        download_app: "–°–∫–∞—á–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ",
        back: "‚Üê –ù–∞–∑–∞–¥",
        next: "–î–∞–ª–µ–µ",
        finish: "–ó–∞–≤–µ—Ä—à–∏—Ç—å",
        solve_problem: "–†–µ—à–∏—Ç–µ –ø—Ä–∏–º–µ—Ä:",
        solve_addition_problem: "–†–µ—à–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –Ω–∞ —Å–ª–æ–∂–µ–Ω–∏–µ:",
        enter_answer: "–í–∞—à –æ—Ç–≤–µ—Ç",
        submit: "–û—Ç–ø—Ä–∞–≤–∏—Ç—å",
        correct: "–ü—Ä–∞–≤–∏–ª—å–Ω–æ!",
        incorrect: "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë!",
        great_job: "–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!",
        excellent_work: "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞!",
        correct_answers: "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ",
        incorrect_answers: "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ",
        try_again: "–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞",
        different_exercise: "–î—Ä—É–≥–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ",
        back_to_dashboard: "–ù–∞–∑–∞–¥ –∫ –ø–∞–Ω–µ–ª–∏",
        your_progress: "–í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å",
        overall_stats: "–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        total_exercises: "–í—Å–µ–≥–æ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π",
        total_correct: "–í—Å–µ–≥–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö",
        best_streak: "–õ—É—á—à–∞—è —Å–µ—Ä–∏—è",
        days_practiced: "–î–Ω–µ–π –∑–∞–Ω—è—Ç–∏–π",
        exercise_breakdown: "–†–∞–∑–±–∏–≤–∫–∞ –ø–æ —Ç–∏–ø–∞–º —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π",
        exercises_completed: "—É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –≤—ã–ø–æ–ª–Ω–µ–Ω–æ",
        completed_all: "–í—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –≤—Å–µ",
        exercises_for_today: "—É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ç–∏–ø.",
        difficulty: "–°–ª–æ–∂–Ω–æ—Å—Ç—å",
        difficulty_easy: "–õ—ë–≥–∫–∏–π",
        difficulty_medium: "–°—Ä–µ–¥–Ω–∏–π",
        difficulty_hard: "–°–ª–æ–∂–Ω—ã–π",
        difficulty_description_easy: "–ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö! –ü—Ä–æ—Å—Ç—ã–µ –ø—Ä–∏–º–µ—Ä—ã —Å –æ–¥–Ω–æ–π —Ü–∏—Ñ—Ä–æ–π.",
        difficulty_description_medium: "–û—Ç–ª–∏—á–Ω–æ –¥–ª—è —É—á–µ–Ω–∏–∫–æ–≤ —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –æ–ø—ã—Ç–æ–º.",
        difficulty_description_hard: "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –º–Ω–æ–≥–æ–∑–Ω–∞—á–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –¥–ª—è —ç–∫—Å–ø–µ—Ä—Ç–æ–≤ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏!",
        expert_level: "–≠–∫—Å–ø–µ—Ä—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏!",
        multi_digit_warning: "–ì–æ—Ç–æ–≤—å—Ç–µ—Å—å –∫ –º–Ω–æ–≥–æ–∑–Ω–∞—á–Ω—ã–º –∏—Å–ø—ã—Ç–∞–Ω–∏—è–º!",
        good_job_easy: "–û—Ç–ª–∏—á–Ω–æ–µ –Ω–∞—á–∞–ª–æ! –í—ã –±—ã—Å—Ç—Ä–æ —É—á–∏—Ç–µ—Å—å!",
        good_job_medium: "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞! –í—ã —Å—Ç–∞–Ω–æ–≤–∏—Ç–µ—Å—å —Å–∏–ª—å–Ω–µ–µ!",
        good_job_hard: "–ü–æ—Ç—Ä—è—Å–∞—é—â–µ! –í—ã —Ä–µ—à–∞–µ—Ç–µ –∑–∞–¥–∞—á–∏ —ç–∫—Å–ø–µ—Ä—Ç–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è!",
        select_difficulty: "–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏",
        change_difficulty: "–ò–∑–º–µ–Ω–∏—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
        current_difficulty: "–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å",
        completed_on: "–ó–∞–≤–µ—Ä—à–µ–Ω–æ –Ω–∞",
        mastered: "–û—Å–≤–æ–µ–Ω–æ!",
        try_harder: "–ì–æ—Ç–æ–≤—ã –∫ –∏—Å–ø—ã—Ç–∞–Ω–∏—é? –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å!",
        good_job_easy: "–û—Ç–ª–∏—á–Ω–æ–µ –Ω–∞—á–∞–ª–æ! –í—ã –±—ã—Å—Ç—Ä–æ —É—á–∏—Ç–µ—Å—å!",
        good_job_medium: "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞! –í—ã —Å—Ç–∞–Ω–æ–≤–∏—Ç–µ—Å—å —Å–∏–ª—å–Ω–µ–µ!",
        good_job_hard: "–ü–æ—Ç—Ä—è—Å–∞—é—â–µ! –í—ã —á–µ–º–ø–∏–æ–Ω –ø–æ –º–∞—Ç–µ–º–∞—Ç–∏–∫–µ!",
        great_addition_skills: "–û—Ç–ª–∏—á–Ω—ã–µ –Ω–∞–≤—ã–∫–∏ —Å–ª–æ–∂–µ–Ω–∏—è!",
        addition_master: "–ú–∞—Å—Ç–µ—Ä —Å–ª–æ–∂–µ–Ω–∏—è!"
      },
      he: {
        app_title: "üéì ◊î◊®◊§◊™◊ß◊™ ◊û◊™◊û◊ò◊ô◊ß◊î! üéì",
        welcome: "◊ë◊ó◊® ◊§◊®◊ï◊§◊ô◊ú ◊ê◊ï ◊¶◊ï◊® ◊ó◊ì◊©!",
        create_user: "◊¶◊ï◊® ◊û◊©◊™◊û◊© ◊ó◊ì◊©",
        select_user: "◊ë◊ó◊® ◊û◊©◊™◊û◊©",
        enter_name: "◊î◊õ◊†◊° ◊ê◊™ ◊©◊û◊ö",
        start_learning: "◊î◊™◊ó◊ú ◊ú◊ú◊û◊ï◊ì!",
        multiplication: "◊õ◊§◊ú",
        subtraction: "◊ó◊ô◊°◊ï◊®",
        division: "◊ó◊ô◊ú◊ï◊ß",
        addition: "◊ó◊ô◊ë◊ï◊®",
        start_exercise: "◊î◊™◊ó◊ú ◊™◊®◊í◊ô◊ú",
        daily_progress: "◊î◊™◊ß◊ì◊û◊ï◊™ ◊ô◊ï◊û◊ô◊™",
        success_rate: "◊ê◊ó◊ï◊ñ ◊î◊¶◊ú◊ó◊î",
        current_streak: "◊®◊¶◊£ ◊†◊ï◊õ◊ó◊ô",
        choose_exercise: "◊ë◊ó◊® ◊™◊®◊í◊ô◊ú",
        your_achievements: "◊î◊î◊ô◊©◊í◊ô◊ù ◊©◊ú◊ö",
        view_progress: "◊¶◊§◊î ◊ë◊î◊™◊ß◊ì◊û◊ï◊™ ◊û◊§◊ï◊®◊ò◊™",
        your_score: "◊î◊¶◊ô◊ï◊ü ◊©◊ú◊ö",
        settings: "◊î◊í◊ì◊®◊ï◊™",
        language: "◊©◊§◊î",
        switch_user: "◊î◊ó◊ú◊£ ◊û◊©◊™◊û◊©",
        download_app: "◊î◊ï◊®◊ì ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î",
        back: "◊ó◊ñ◊ï◊® ‚Üê",
        next: "◊î◊ë◊ê",
        finish: "◊°◊ô◊ô◊ù",
        solve_problem: "◊§◊™◊ï◊® ◊ê◊™ ◊î◊ë◊¢◊ô◊î:",
        solve_addition_problem: "◊§◊™◊ï◊® ◊ê◊™ ◊ë◊¢◊ô◊ô◊™ ◊î◊ó◊ô◊ë◊ï◊®:",
        enter_answer: "◊î◊™◊©◊ï◊ë◊î ◊©◊ú◊ö",
        submit: "◊©◊ú◊ó",
        correct: "◊†◊õ◊ï◊ü!",
        incorrect: "◊†◊°◊î ◊©◊ï◊ë!",
        great_job: "◊¢◊ë◊ï◊ì◊î ◊û◊¶◊ï◊ô◊†◊™!",
        excellent_work: "◊¢◊ë◊ï◊ì◊î ◊û◊¶◊ï◊ô◊†◊™!",
        correct_answers: "◊†◊õ◊ï◊†◊ï◊™",
        incorrect_answers: "◊©◊í◊ï◊ô◊ï◊™",
        try_again: "◊†◊°◊î ◊©◊ï◊ë",
        different_exercise: "◊™◊®◊í◊ô◊ú ◊ê◊ó◊®",
        back_to_dashboard: "◊ó◊ñ◊ï◊® ◊ú◊ú◊ï◊ó ◊î◊ë◊ß◊®◊î",
        your_progress: "◊î◊î◊™◊ß◊ì◊û◊ï◊™ ◊©◊ú◊ö",
        overall_stats: "◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊õ◊ú◊ú◊ô◊ï◊™",
        total_exercises: "◊°◊ö ◊î◊™◊®◊í◊ô◊ú◊ô◊ù",
        total_correct: "◊°◊ö ◊î◊†◊õ◊ï◊†◊ï◊™",
        best_streak: "◊î◊®◊¶◊£ ◊î◊ò◊ï◊ë ◊ë◊ô◊ï◊™◊®",
        days_practiced: "◊ô◊û◊ô ◊™◊®◊í◊ï◊ú",
        exercise_breakdown: "◊§◊ô◊ú◊ï◊ó ◊ú◊§◊ô ◊°◊ï◊í◊ô ◊™◊®◊í◊ô◊ú◊ô◊ù",
        exercises_completed: "◊™◊®◊í◊ô◊ú◊ô◊ù ◊î◊ï◊©◊ú◊û◊ï",
        completed_all: "◊î◊©◊ú◊û◊™ ◊ê◊™ ◊õ◊ú",
        exercises_for_today: "◊î◊™◊®◊í◊ô◊ú◊ô◊ù ◊ú◊ô◊ï◊ù! ◊†◊°◊î ◊°◊ï◊í ◊ê◊ó◊®.",
        difficulty: "◊®◊û◊™ ◊ß◊ï◊©◊ô",
        difficulty_easy: "◊ß◊ú",
        difficulty_medium: "◊ë◊ô◊†◊ï◊†◊ô",
        difficulty_hard: "◊ß◊©◊î",
        difficulty_description_easy: "◊û◊ï◊©◊ú◊ù ◊ú◊û◊™◊ó◊ô◊ú◊ô◊ù! ◊ë◊¢◊ô◊ï◊™ ◊§◊©◊ï◊ò◊ï◊™ ◊¢◊ù ◊°◊§◊®◊î ◊ê◊ó◊™.",
        difficulty_description_medium: "◊†◊î◊ì◊® ◊ú◊™◊ú◊û◊ô◊ì◊ô◊ù ◊¢◊ù ◊ß◊¶◊™ ◊†◊ô◊°◊ô◊ï◊ü.",
        difficulty_description_hard: "◊ë◊¢◊ô◊ï◊™ ◊û◊™◊ß◊ì◊û◊ï◊™ ◊û◊®◊ï◊ë◊ï◊™ ◊°◊§◊®◊ï◊™ ◊ú◊û◊ï◊û◊ó◊ô ◊û◊™◊û◊ò◊ô◊ß◊î!",
        expert_level: "◊ë◊¢◊ô◊ï◊™ ◊ë◊®◊û◊™ ◊û◊ï◊û◊ó◊î!",
        multi_digit_warning: "◊î◊™◊õ◊ï◊†◊ü ◊ú◊ê◊™◊í◊®◊ô◊ù ◊®◊ë-◊°◊§◊®◊™◊ô◊ô◊ù!",
        good_job_easy: "◊î◊™◊ó◊ú◊î ◊†◊î◊ì◊®◊™! ◊ê◊™◊î ◊ú◊ï◊û◊ì ◊û◊î◊®!",
        good_job_medium: "◊¢◊ë◊ï◊ì◊î ◊û◊¶◊ï◊ô◊†◊™! ◊ê◊™◊î ◊†◊¢◊©◊î ◊ó◊ñ◊ß ◊ô◊ï◊™◊®!",
        good_job_hard: "◊û◊ì◊î◊ô◊ù! ◊ê◊™◊î ◊§◊ï◊™◊® ◊ë◊¢◊ô◊ï◊™ ◊ë◊®◊û◊™ ◊û◊ï◊û◊ó◊î!",
        select_difficulty: "◊ë◊ó◊® ◊®◊û◊™ ◊ß◊ï◊©◊ô",
        change_difficulty: "◊©◊†◊î ◊®◊û◊™ ◊ß◊ï◊©◊ô",
        current_difficulty: "◊®◊û◊î ◊†◊ï◊õ◊ó◊ô◊™",
        completed_on: "◊î◊ï◊©◊ú◊ù ◊ë◊®◊û◊î",
        mastered: "◊©◊ï◊ú◊ò!",
        try_harder: "◊û◊ï◊õ◊ü ◊ú◊ê◊™◊í◊®? ◊†◊°◊î ◊ê◊™ ◊î◊®◊û◊î ◊î◊ë◊ê◊î!",
        good_job_easy: "◊î◊™◊ó◊ú◊î ◊†◊î◊ì◊®◊™! ◊ê◊™◊î ◊ú◊ï◊û◊ì ◊û◊î◊®!",
        good_job_medium: "◊¢◊ë◊ï◊ì◊î ◊û◊¶◊ï◊ô◊†◊™! ◊ê◊™◊î ◊†◊¢◊©◊î ◊ó◊ñ◊ß ◊ô◊ï◊™◊®!",
        good_job_hard: "◊û◊ì◊î◊ô◊ù! ◊ê◊™◊î ◊ê◊ú◊ï◊£ ◊ë◊û◊™◊û◊ò◊ô◊ß◊î!",
        great_addition_skills: "◊õ◊ô◊©◊ï◊®◊ô ◊ó◊ô◊ë◊ï◊® ◊û◊¢◊ï◊ú◊ô◊ù!",
        addition_master: "◊û◊ï◊û◊ó◊î ◊ó◊ô◊ë◊ï◊®!"
      }
    };
    this.currentExercise = {
      type: null,
      questions: [],
      currentQuestion: 0,
      answers: [],
      startTime: null
    };
    
    // App configuration
    this.exerciseTypes = {
      multiplication: { name: 'Multiplication', symbol: '√ó', color: '#FF6B6B', range: [1, 12] },
      subtraction: { name: 'Subtraction', symbol: '‚àí', color: '#4ECDC4', range: [1, 100] },
      division: { name: 'Division', symbol: '√∑', color: '#45B7D1', range: [1, 12] },
      addition: { name: 'Addition', symbol: '+', color: '#9C27B0', range: [1, 20] }
    };
    
    this.avatars = ['üê±', 'üê∂', 'üêº', 'ü¶Å', 'üê∏', 'üêô', 'ü¶Ñ', 'üêß'];
    
    this.achievements = {
      first_steps: {
        en: { name: 'First Steps', description: 'Complete your first exercise' },
        ru: { name: '–ü–µ—Ä–≤—ã–µ —à–∞–≥–∏', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ –≤–∞—à–µ –ø–µ—Ä–≤–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ' },
        he: { name: '◊¶◊¢◊ì◊ô◊ù ◊®◊ê◊©◊ï◊†◊ô◊ù', description: '◊î◊©◊ú◊ù ◊ê◊™ ◊î◊™◊®◊í◊ô◊ú ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú◊ö' },
        icon: 'üåü'
      },
      easy_master: {
        en: { name: 'Easy Master', description: 'Complete 50 easy exercises with 90%+ accuracy' },
        ru: { name: '–ú–∞—Å—Ç–µ—Ä –ª—ë–≥–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ 50 –ª—ë–≥–∫–∏—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 90%+' },
        he: { name: '◊©◊ï◊ú◊ò ◊ë◊®◊û◊î ◊î◊ß◊ú◊î', description: '◊î◊©◊ú◊ù 50 ◊™◊®◊í◊ô◊ú◊ô◊ù ◊ß◊ú◊ô◊ù ◊¢◊ù ◊ì◊ô◊ï◊ß ◊©◊ú 90%+' },
        icon: 'üçè'
      },
      medium_master: {
        en: { name: 'Medium Master', description: 'Complete 50 medium exercises with 90%+ accuracy' },
        ru: { name: '–ú–∞—Å—Ç–µ—Ä —Å—Ä–µ–¥–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ 50 —Å—Ä–µ–¥–Ω–∏—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 90%+' },
        he: { name: '◊©◊ï◊ú◊ò ◊ë◊®◊û◊î ◊î◊ë◊ô◊†◊ï◊†◊ô◊™', description: '◊î◊©◊ú◊ù 50 ◊™◊®◊í◊ô◊ú◊ô◊ù ◊ë◊ô◊†◊ï◊†◊ô◊ô◊ù ◊¢◊ù ◊ì◊ô◊ï◊ß ◊©◊ú 90%+' },
        icon: 'ü•â'
      },
      hard_master: {
        en: { name: 'Hard Master', description: 'Complete 50 hard exercises with 90%+ accuracy' },
        ru: { name: '–ú–∞—Å—Ç–µ—Ä —Å–ª–æ–∂–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ 50 —Å–ª–æ–∂–Ω—ã—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 90%+' },
        he: { name: '◊©◊ï◊ú◊ò ◊ë◊®◊û◊î ◊î◊ß◊©◊î', description: '◊î◊©◊ú◊ù 50 ◊™◊®◊í◊ô◊ú◊ô◊ù ◊ß◊©◊ô◊ù ◊¢◊ù ◊ì◊ô◊ï◊ß ◊©◊ú 90%+' },
        icon: 'üî•'
      },
      daily_warrior: {
        en: { name: 'Daily Warrior', description: 'Complete all daily exercises' },
        ru: { name: '–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –≤–æ–∏–Ω', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è' },
        he: { name: '◊ú◊ï◊ó◊ù ◊ô◊ï◊û◊ô', description: '◊î◊©◊ú◊ù ◊ê◊™ ◊õ◊ú ◊î◊™◊®◊í◊ô◊ú◊ô◊ù ◊î◊ô◊ï◊û◊ô◊ô◊ù' },
        icon: 'üèÜ'
      },
      perfect_score: {
        en: { name: 'Perfect Score', description: 'Get 100% on an exercise set' },
        ru: { name: '–ò–¥–µ–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç', description: '–ü–æ–ª—É—á–∏—Ç–µ 100% –≤ –Ω–∞–±–æ—Ä–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π' },
        he: { name: '◊¶◊ô◊ï◊ü ◊û◊ï◊©◊ú◊ù', description: '◊ß◊ë◊ú 100% ◊ë◊°◊ò ◊™◊®◊í◊ô◊ú◊ô◊ù' },
        icon: 'üíØ'
      },
      week_streak: {
        en: { name: 'Week Streak', description: 'Practice for 7 days in a row' },
        ru: { name: '–ù–µ–¥–µ–ª—å–Ω–∞—è —Å–µ—Ä–∏—è', description: '–ó–∞–Ω–∏–º–∞–π—Ç–µ—Å—å 7 –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥' },
        he: { name: '◊®◊¶◊£ ◊©◊ë◊ï◊¢◊ô', description: '◊™◊®◊í◊ú 7 ◊ô◊û◊ô◊ù ◊ë◊®◊¶◊£' },
        icon: 'üî•'
      },
      addition_beginner: {
        en: { name: 'Addition Beginner', description: 'Complete 10 easy addition exercises' },
        ru: { name: '–ù–æ–≤–∏—á–æ–∫ –≤ —Å–ª–æ–∂–µ–Ω–∏–∏', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ 10 –ª—ë–≥–∫–∏—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –Ω–∞ —Å–ª–æ–∂–µ–Ω–∏–µ' },
        he: { name: '◊û◊™◊ó◊ô◊ú ◊ë◊ó◊ô◊ë◊ï◊®', description: '◊î◊©◊ú◊ù 10 ◊™◊®◊í◊ô◊ú◊ô ◊ó◊ô◊ë◊ï◊® ◊ß◊ú◊ô◊ù' },
        icon: '‚ûï'
      },
      addition_expert: {
        en: { name: 'Addition Expert', description: 'Complete 50 hard addition exercises with 80%+ accuracy' },
        ru: { name: '–≠–∫—Å–ø–µ—Ä—Ç —Å–ª–æ–∂–µ–Ω–∏—è', description: '–í—ã–ø–æ–ª–Ω–∏—Ç–µ 50 —Å–ª–æ–∂–Ω—ã—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –Ω–∞ —Å–ª–æ–∂–µ–Ω–∏–µ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 80%+' },
        he: { name: '◊û◊ï◊û◊ó◊î ◊ó◊ô◊ë◊ï◊®', description: '◊î◊©◊ú◊ù 50 ◊™◊®◊í◊ô◊ú◊ô ◊ó◊ô◊ë◊ï◊® ◊ß◊©◊ô◊ù ◊¢◊ù ◊ì◊ô◊ï◊ß ◊©◊ú 80%+' },
        icon: 'üéØ'
      }
    };
    
    this.encouragingMessagesByDifficulty = {
      easy: {
        correct: {
          en: ["Great start!", "You're learning!", "Keep it up!", "Nice work!", "Well done!"],
          ru: ["–û—Ç–ª–∏—á–Ω–æ–µ –Ω–∞—á–∞–ª–æ!", "–í—ã —É—á–∏—Ç–µ—Å—å!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ!", "–•–æ—Ä–æ—à–∞—è —Ä–∞–±–æ—Ç–∞!", "–ú–æ–ª–æ–¥–µ—Ü!"],
          he: ["◊î◊™◊ó◊ú◊î ◊†◊î◊ì◊®◊™!", "◊ê◊™◊î ◊ú◊ï◊û◊ì!", "◊î◊û◊©◊ö ◊õ◊ö!", "◊¢◊ë◊ï◊ì◊î ◊ô◊§◊î!", "◊õ◊ú ◊î◊õ◊ë◊ï◊ì!"]
        },
        incorrect: {
          en: ["Try again!", "You can do it!", "Almost there!", "Keep trying!", "Don't give up!"],
          ru: ["–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!", "–£ –≤–∞—Å –ø–æ–ª—É—á–∏—Ç—Å—è!", "–ü–æ—á—Ç–∏!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å—Ç–∞—Ä–∞—Ç—å—Å—è!", "–ù–µ —Å–¥–∞–≤–∞–π—Ç–µ—Å—å!"],
          he: ["◊†◊°◊î ◊©◊ï◊ë!", "◊ê◊™◊î ◊ô◊õ◊ï◊ú!", "◊õ◊û◊¢◊ò ◊©◊ù!", "◊î◊û◊©◊ö ◊ú◊†◊°◊ï◊™!", "◊ê◊ú ◊™◊ï◊ï◊™◊®!"]
        }
      },
      medium: {
        correct: {
          en: ["Excellent work!", "You're getting stronger!", "Great progress!", "Impressive!", "Keep going!"],
          ru: ["–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!", "–í—ã —Å—Ç–∞–Ω–æ–≤–∏—Ç–µ—Å—å —Å–∏–ª—å–Ω–µ–µ!", "–û—Ç–ª–∏—á–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å!", "–í–ø–µ—á–∞—Ç–ª—è—é—â–µ!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ!"],
          he: ["◊¢◊ë◊ï◊ì◊î ◊û◊¶◊ï◊ô◊†◊™!", "◊ê◊™◊î ◊†◊¢◊©◊î ◊ó◊ñ◊ß ◊ô◊ï◊™◊®!", "◊î◊™◊ß◊ì◊û◊ï◊™ ◊†◊î◊ì◊®◊™!", "◊û◊®◊©◊ô◊ù!", "◊î◊û◊©◊ö!"]
        },
        incorrect: {
          en: ["Close!", "Try once more!", "You're improving!", "Almost got it!", "Keep practicing!"],
          ru: ["–ë–ª–∏–∑–∫–æ!", "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!", "–í—ã —É–ª—É—á—à–∞–µ—Ç–µ—Å—å!", "–ü–æ—á—Ç–∏ –ø–æ–ª—É—á–∏–ª–æ—Å—å!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è!"],
          he: ["◊ß◊®◊ï◊ë!", "◊†◊°◊î ◊¢◊ï◊ì ◊§◊¢◊ù!", "◊ê◊™◊î ◊û◊©◊™◊§◊®!", "◊õ◊û◊¢◊ò ◊î◊¶◊ú◊ó◊™!", "◊î◊û◊©◊ö ◊ú◊î◊™◊ê◊û◊ü!"]
        }
      },
      hard: {
        correct: {
          en: ["Incredible calculation!", "Math genius!", "Expert level work!", "Outstanding problem solving!", "You're mastering complex math!"],
          ru: ["–ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è!", "–ì–µ–Ω–∏–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏!", "–†–∞–±–æ—Ç–∞ —ç–∫—Å–ø–µ—Ä—Ç–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è!", "–í—ã–¥–∞—é—â–µ–µ—Å—è —Ä–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á!", "–í—ã –æ—Å–≤–∞–∏–≤–∞–µ—Ç–µ —Å–ª–æ–∂–Ω—É—é –º–∞—Ç–µ–º–∞—Ç–∏–∫—É!"],
          he: ["◊ó◊ô◊©◊ï◊ë ◊ë◊ú◊™◊ô ◊®◊í◊ô◊ú!", "◊í◊ê◊ï◊ü ◊ë◊û◊™◊û◊ò◊ô◊ß◊î!", "◊¢◊ë◊ï◊ì◊î ◊ë◊®◊û◊™ ◊û◊ï◊û◊ó◊î!", "◊§◊™◊®◊ï◊ü ◊ë◊¢◊ô◊ï◊™ ◊ô◊ï◊¶◊ê ◊û◊ü ◊î◊õ◊ú◊ú!", "◊ê◊™◊î ◊©◊ï◊ú◊ò ◊ë◊û◊™◊û◊ò◊ô◊ß◊î ◊û◊ï◊®◊õ◊ë◊™!"]
        },
        incorrect: {
          en: ["Complex problem - try again!", "Multi-digit math is challenging!", "You're tackling expert problems!", "Keep working on it!", "Advanced math takes practice!"],
          ru: ["–°–ª–æ–∂–Ω–∞—è –∑–∞–¥–∞—á–∞ - –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!", "–ú–Ω–æ–≥–æ–∑–Ω–∞—á–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞ —Å–ª–æ–∂–Ω–∞!", "–í—ã —Ä–µ—à–∞–µ—Ç–µ —ç–∫—Å–ø–µ—Ä—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å!", "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞ —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–∞–∫—Ç–∏–∫–∏!"],
          he: ["◊ë◊¢◊ô◊î ◊û◊ï◊®◊õ◊ë◊™ - ◊†◊°◊î ◊©◊ï◊ë!", "◊û◊™◊û◊ò◊ô◊ß◊î ◊®◊ë-◊°◊§◊®◊™◊ô◊™ ◊û◊ê◊™◊í◊®◊™!", "◊ê◊™◊î ◊û◊™◊û◊ï◊ì◊ì ◊¢◊ù ◊ë◊¢◊ô◊ï◊™ ◊û◊ï◊û◊ó◊î!", "◊î◊û◊©◊ö ◊ú◊¢◊ë◊ï◊ì ◊¢◊ú ◊ñ◊î!", "◊û◊™◊û◊ò◊ô◊ß◊î ◊û◊™◊ß◊ì◊û◊™ ◊ì◊ï◊®◊©◊™ ◊™◊®◊í◊ï◊ú!"]
        },
        addition: {
          correct: {
            en: ["Excellent addition!", "Great addition skills!", "You're an addition expert!", "Perfect work!", "Accurate addition!"],
            ru: ["–û—Ç–ª–∏—á–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ!", "–ü—Ä–µ–∫—Ä–∞—Å–Ω—ã–µ –Ω–∞–≤—ã–∫–∏ —Å–ª–æ–∂–µ–Ω–∏—è!", "–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ —Å–ª–æ–∂–µ–Ω–∏—é!", "–ò–¥–µ–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞!", "–¢–æ—á–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ!"],
            he: ["◊ó◊ô◊ë◊ï◊® ◊û◊¶◊ï◊ô◊ü!", "◊õ◊ô◊©◊ï◊®◊ô ◊ó◊ô◊ë◊ï◊® ◊†◊î◊ì◊®◊ô◊ù!", "◊ê◊™◊î ◊û◊ï◊û◊ó◊î ◊ë◊ó◊ô◊ë◊ï◊®!", "◊¢◊ë◊ï◊ì◊î ◊û◊ï◊©◊ú◊û◊™!", "◊ó◊ô◊ë◊ï◊® ◊û◊ì◊ï◊ô◊ß!"]
          },
          incorrect: {
            en: ["Try the addition again!", "Addition needs practice!", "Almost got it!", "Keep practicing addition!", "Don't give up on addition!"],
            ru: ["–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–ª–æ–∂–µ–Ω–∏–µ —Å–Ω–æ–≤–∞!", "–°–ª–æ–∂–µ–Ω–∏–µ —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–∞–∫—Ç–∏–∫–∏!", "–ü–æ—á—Ç–∏ –ø–æ–ª—É—á–∏–ª–æ—Å—å!", "–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–ª–æ–∂–µ–Ω–∏–µ!", "–ù–µ —Å–¥–∞–≤–∞–π—Ç–µ—Å—å –≤ —Å–ª–æ–∂–µ–Ω–∏–∏!"],
            he: ["◊†◊°◊î ◊©◊ï◊ë ◊ê◊™ ◊î◊ó◊ô◊ë◊ï◊®!", "◊ó◊ô◊ë◊ï◊® ◊ì◊ï◊®◊© ◊™◊®◊í◊ï◊ú!", "◊õ◊û◊¢◊ò ◊î◊¶◊ú◊ó◊™!", "◊î◊û◊©◊ö ◊ú◊™◊®◊í◊ú ◊ó◊ô◊ë◊ï◊®!", "◊ê◊ú ◊™◊ï◊ï◊™◊® ◊¢◊ú ◊î◊ó◊ô◊ë◊ï◊®!"]
          }
        }
      }
    };
    
    this.currentScreen = 'user-selection';
    
    console.log('MathApp constructor completed, starting initialization...');
    this.init();
  }
  
  validateMethods() {
    console.log('Validating methods...');
    
    const requiredMethods = [
      'saveToStorage', 'getFromStorage', 'loadUsersFromStorage',
      'createUser', 'createUserWithFullStructure', 'bindEvents',
      'showScreen', 'updateLanguage', 'translate'
    ];
    
    const missingMethods = requiredMethods.filter(method => {
      const exists = typeof this[method] === 'function';
      if (!exists) {
        console.error(`‚ö†Ô∏è Method ${method} is not defined or not a function`);
      }
      return !exists;
    });
    
    if (missingMethods.length > 0) {
      throw new Error(`Missing required methods: ${missingMethods.join(', ')}`);
    }
    
    console.log('‚úÖ All required methods validated successfully');
  }
  
  init() {
    console.log('Initializing Math App...');
    
    try {
      this.showLoadingIndicator();
      
      setTimeout(() => {
        try {
          console.log('Starting initialization sequence...');
          
          this.detectLanguage();
          console.log('Language detected:', this.currentLanguage);
          
          this.bindEvents();
          console.log('Events bound successfully');
          
          this.loadUsersFromStorage();
          console.log('Users loaded, count:', this.users.length);
          
          this.showScreen('user-selection');
          console.log('Screen shown: user-selection');
          
          this.renderUserSelection();
          console.log('User selection rendered');
          
          this.renderAvatarSelection();
          console.log('Avatar selection rendered');
          
          this.updateLanguage();
          console.log('Language updated');
          
          this.hideLoadingIndicator();
          console.log('Loading indicator hidden');
          
          // Show welcome message if returning user
          if (this.users.length > 0) {
            this.showDataRestoredMessage();
            console.log('Welcome message shown for returning user');
          }
          
          console.log('‚úÖ Math App initialized successfully!');
          
        } catch (error) {
          console.error('‚ö†Ô∏è Error during initialization:', error);
          this.hideLoadingIndicator();
          
          const errorMsg = this.currentLanguage === 'he' ? '◊©◊í◊ô◊ê◊î ◊ë◊ê◊ô◊†◊ô◊¶◊ô◊ê◊ú◊ô◊ñ◊¶◊ô◊î' :
                          this.currentLanguage === 'ru' ? '–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏' :
                          'Initialization error';
          alert(errorMsg + ': ' + error.message);
        }
      }, 500); // Simulate loading time
      
    } catch (error) {
      console.error('‚ö†Ô∏è Critical initialization error:', error);
      alert('Critical error starting the app: ' + error.message);
    }
  }
  
  showLoadingIndicator() {
    const indicator = document.getElementById('loading-indicator');
    if (indicator) {
      indicator.style.display = 'block';
    }
  }
  
  hideLoadingIndicator() {
    const indicator = document.getElementById('loading-indicator');
    if (indicator) {
      indicator.style.display = 'none';
    }
  }
  
  detectLanguage() {
    // Set Hebrew as default language, with fallback to browser language
    this.currentLanguage = 'he';
    // Uncomment below for auto-detection based on browser language
    // const browserLang = navigator.language.substring(0, 2);
    // if (this.languages[browserLang]) {
    //   this.currentLanguage = browserLang;
    // } else {
    //   this.currentLanguage = 'he';
    // }
  }
  
  setLanguage(langCode) {
    if (this.languages[langCode]) {
      this.currentLanguage = langCode;
      this.updateLanguage();
      this.saveToStorage(); // Save language preference
    }
  }
  
  updateLanguage() {
    const lang = this.languages[this.currentLanguage];
    const translations = this.translations[this.currentLanguage];
    
    // Set document direction
    document.documentElement.dir = lang.direction;
    document.documentElement.lang = lang.code;
    
    // Update all elements with data-i18n attributes
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      if (translations[key]) {
        element.textContent = translations[key];
      }
    });
    
    // Update placeholders
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
      const key = element.getAttribute('data-i18n-placeholder');
      if (translations[key]) {
        element.placeholder = translations[key];
      }
    });
    
    // Update language selectors
    document.querySelectorAll('#language-select, #main-language-select').forEach(select => {
      select.value = this.currentLanguage;
    });
    
    // Update page title
    document.title = translations.app_title || 'Math Adventure';
    
    // Update exercise type names in data structures
    this.exerciseTypes.multiplication.name = translations.multiplication;
    this.exerciseTypes.subtraction.name = translations.subtraction;
    this.exerciseTypes.division.name = translations.division;
  }
  
  translate(key) {
    return this.translations[this.currentLanguage][key] || key;
  }
  
  // Load users from storage simulation or start with empty array
  loadUsersFromStorage() {
    try {
      const savedData = this.getFromStorage('mathApp_userData');
      if (savedData && savedData.users && Array.isArray(savedData.users)) {
        // Validate and clean each user object
        this.users = savedData.users.filter(user => {
          return user && user.id && user.name;
        }).map(user => {
          // Ensure all required properties exist with fallbacks
          return {
            ...user,
            id: user.id || Date.now().toString(),
            createdDate: user.createdDate || user.createdAt || new Date().toISOString(),
            language: user.language || 'he',
            currentDifficulty: user.currentDifficulty || user.difficultyPreference || 'easy',
            stats: user.stats || {
              totalExercises: 0,
              totalCorrect: 0,
              currentStreak: 0,
              bestStreak: 0,
              daysPracticed: 0,
              lastPracticeDate: null
            },
            exerciseStats: user.exerciseStats || {
              multiplication: { total: 0, correct: 0 },
              subtraction: { total: 0, correct: 0 },
              division: { total: 0, correct: 0 },
              addition: { total: 0, correct: 0 }
            },
            dailyProgress: user.dailyProgress || {
              date: this.getTodayString(),
              multiplication: 0,
              subtraction: 0,
              division: 0,
              addition: 0
            },
            achievements: user.achievements || [],
            difficultyStats: user.difficultyStats || {
              easy: { total: 0, correct: 0 },
              medium: { total: 0, correct: 0 },
              hard: { total: 0, correct: 0 }
            },
            exerciseHistory: user.exerciseHistory || []
          };
        });
        
        // Restore last active user if exists
        if (savedData.appSettings && savedData.appSettings.lastActiveUser) {
          this.currentUser = this.users.find(u => u && u.id === savedData.appSettings.lastActiveUser);
          if (this.currentUser) {
            this.currentDifficulty = this.currentUser.difficultyPreference || this.currentUser.currentDifficulty || 'easy';
          }
        }
        
        console.log(`‚úÖ Loaded ${this.users.length} users from storage`);
      } else {
        // Start with empty user list - force users to create their own profiles
        this.users = [];
        console.log('üÜï Starting with empty user list - create your first user!');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error loading user data, starting fresh:', error);
      this.users = [];
    }
    
    this.validateAndCleanupData();
  }
  
  bindEvents() {
    console.log('Binding events...');
    
    // User selection events with proper error handling
    const createUserBtn = document.getElementById('create-user-btn');
    if (createUserBtn) {
      createUserBtn.addEventListener('click', (e) => {
        console.log('Create user button clicked');
        try {
          this.createUser();
        } catch (error) {
          console.error('‚ùå Error in createUser:', error);
          const errorMsg = this.currentLanguage === 'he' ? '◊©◊í◊ô◊ê◊î ◊ë◊ô◊¶◊ô◊®◊™ ◊û◊©◊™◊û◊©' :
                          this.currentLanguage === 'ru' ? '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' :
                          'Error creating user';
          alert(errorMsg + ': ' + error.message);
        }
      });
    } else {
      console.warn('‚ö†Ô∏è Create user button not found');
    }
    
    const switchUserBtn = document.getElementById('switch-user-btn');
    if (switchUserBtn) {
      switchUserBtn.addEventListener('click', () => this.showScreen('user-selection'));
    }
    
    // Dashboard events
    document.querySelectorAll('.exercise-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.startExercise(e.currentTarget.dataset.type));
    });
    
    // Difficulty selection events
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.selectDifficulty(e.currentTarget.dataset.difficulty));
    });
    document.getElementById('change-difficulty-btn')?.addEventListener('click', () => this.showDifficultySelector());
    document.getElementById('view-progress-btn').addEventListener('click', () => this.showScreen('progress'));
    
    // Exercise events
    document.getElementById('back-to-dashboard').addEventListener('click', () => this.showScreen('dashboard'));
    document.getElementById('submit-answer').addEventListener('click', () => this.submitAnswer());
    document.getElementById('next-question').addEventListener('click', () => this.nextQuestion());
    document.getElementById('answer-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.submitAnswer();
    });
    
    // Results events
    document.getElementById('try-again-btn').addEventListener('click', () => this.retryExercise());
    document.getElementById('different-exercise-btn').addEventListener('click', () => this.showScreen('dashboard'));
    document.getElementById('back-dashboard-btn').addEventListener('click', () => this.showScreen('dashboard'));
    
    // Progress events
    document.getElementById('back-from-progress').addEventListener('click', () => this.showScreen('dashboard'));
    
    // Language selection events
    document.getElementById('language-select')?.addEventListener('change', (e) => this.setLanguage(e.target.value));
    document.getElementById('main-language-select')?.addEventListener('change', (e) => this.setLanguage(e.target.value));
    
    // Download app event
    document.getElementById('download-app-btn')?.addEventListener('click', () => this.downloadApp());
    
    // Avatar selection events
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('avatar-option')) {
        document.querySelectorAll('.avatar-option').forEach(opt => opt.classList.remove('selected'));
        e.target.classList.add('selected');
      }
      if (e.target.classList.contains('user-card')) {
        const userId = e.target.dataset.userId;
        if (userId) {
          this.selectUser(userId);
        } else {
          console.error('‚ùå User ID not found on user card');
        }
      }
    });
  }
  
  showScreen(screenName) {
    document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
    document.getElementById(screenName).classList.add('active');
    this.currentScreen = screenName;
    
    // Update screen-specific content
    if (screenName === 'dashboard' && this.currentUser) {
      this.updateDashboard();
    } else if (screenName === 'progress' && this.currentUser) {
      this.updateProgressScreen();
    } else if (screenName === 'exercise' && this.currentUser) {
      this.updateDifficultyDisplay();
    }
    
    // Re-apply translations when switching screens
    this.updateLanguage();
  }
  
  renderUserSelection() {
    const container = document.getElementById('existing-users');
    if (!container) {
      console.error('‚ùå existing-users container not found');
      return;
    }
    
    container.innerHTML = '';
    
    if (!this.users || this.users.length === 0) {
      // Show "no users" message when starting fresh
      const noUsersMessage = document.createElement('div');
      noUsersMessage.className = 'no-users-message';
      noUsersMessage.style.cssText = `
        text-align: center;
        padding: 40px 20px;
        background: var(--color-bg-2);
        border-radius: var(--radius-lg);
        border: 2px dashed var(--color-border);
        margin: 20px 0;
      `;
      
      const noUsersTitle = this.currentLanguage === 'he' ? '◊ê◊ô◊ü ◊û◊©◊™◊û◊©◊ô◊ù' :
                           this.currentLanguage === 'ru' ? '–ù◊ï—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç◊ï–ª◊ï–π' :
                           'No Users';
      const createFirstUser = this.currentLanguage === 'he' ? '◊¶◊ï◊® ◊ê◊™ ◊î◊û◊©◊™◊û◊© ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú◊ö' :
                              this.currentLanguage === 'ru' ? '–°–æ–∑–¥–∞–π—Ç◊ï —Å–≤–æ◊ï–≥–æ –ø◊ï—Ä–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç◊ï–ª—è' :
                              'Create Your First User';
      
      noUsersMessage.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 16px;">üë§‚ú®</div>
        <h3 style="margin-bottom: 8px; color: var(--color-text);">${noUsersTitle}</h3>
        <p style="color: var(--color-text-secondary); margin-bottom: 0;">${createFirstUser}</p>
      `;
      
      container.appendChild(noUsersMessage);
    } else {
      // Show existing users
      this.users.filter(user => user && user.id && user.name).forEach(user => {
        const userCard = document.createElement('div');
        userCard.className = 'user-card';
        userCard.dataset.userId = user.id;
        
        const userStats = user.stats || { totalExercises: 0, totalCorrect: 0, currentStreak: 0 };
        const successRate = userStats.totalExercises > 0 
          ? Math.round((userStats.totalCorrect / userStats.totalExercises) * 100)
          : 0;
        
        const streakText = this.currentLanguage === 'he' ? '◊®◊¶◊£' :
                          this.currentLanguage === 'ru' ? '–°◊ï—Ä–∏—è' :
                          'Streak';
        const successText = this.currentLanguage === 'he' ? '◊ê◊ó◊ï◊ñ ◊î◊¶◊ú◊ó◊î' :
                           this.currentLanguage === 'ru' ? '–£—Å–ø◊ï—Ö' :
                           'Success Rate';
        const daysText = this.currentLanguage === 'he' ? '◊ô◊û◊ô◊ù' :
                        this.currentLanguage === 'ru' ? '–¥–Ω◊ï–π' :
                        'days';
        
        userCard.innerHTML = `
          <div class="user-avatar">${user.avatar}</div>
          <div class="user-name">${user.name}</div>
          <div class="user-stats">
            ${successText}: ${successRate}%<br>
            ${streakText}: ${userStats.currentStreak || 0} ${daysText}
          </div>
        `;
        
        container.appendChild(userCard);
      });
    }
  }
  
  renderAvatarSelection() {
    const container = document.getElementById('avatar-selection');
    container.innerHTML = '';
    
    this.avatars.forEach(avatar => {
      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar-option';
      avatarDiv.textContent = avatar;
      container.appendChild(avatarDiv);
    });
  }
  
  createUser() {
    console.log('Creating user...');
    
    const nameInput = document.getElementById('new-user-name');
    const selectedAvatar = document.querySelector('.avatar-option.selected');
    
    if (!nameInput || !nameInput.value.trim()) {
      const enterNameMsg = this.currentLanguage === 'he' ? '◊ê◊†◊ê ◊î◊õ◊†◊° ◊©◊ù!' : 
                          this.currentLanguage === 'ru' ? '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∏–º—è!' : 
                          'Please enter a name!';
      alert(enterNameMsg);
      return;
    }
    
    if (!selectedAvatar) {
      const chooseAvatarMsg = this.currentLanguage === 'he' ? '◊ê◊†◊ê ◊ë◊ó◊® ◊ê◊ï◊ï◊ò◊®!' : 
                             this.currentLanguage === 'ru' ? '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∞–≤–∞—Ç–∞—Ä!' : 
                             'Please choose an avatar!';
      alert(chooseAvatarMsg);
      return;
    }
    
    try {
      const userName = nameInput.value.trim();
      const userAvatar = selectedAvatar.textContent;
      
      if (!userName || !userAvatar) {
        throw new Error('User name and avatar are required');
      }
      
      const newUser = this.createUserWithFullStructure(userName, userAvatar);
      
      if (!newUser || !newUser.id) {
        throw new Error('Failed to create user object with required properties');
      }
      
      this.users.push(newUser);
      
      // Save user data immediately
      this.saveToStorage();
      
      // Show success message
      const successMsg = this.currentLanguage === 'he' ? '◊û◊©◊™◊û◊© ◊†◊ï◊¶◊® ◊ë◊î◊¶◊ú◊ó◊î!' :
                        this.currentLanguage === 'ru' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!' :
                        'User created successfully!';
      console.log(successMsg, 'User ID:', newUser.id);
      
      this.selectUser(newUser.id);
      
      // Clear form
      nameInput.value = '';
      document.querySelectorAll('.avatar-option').forEach(opt => opt.classList.remove('selected'));
      
    } catch (error) {
      const errorMsg = this.currentLanguage === 'he' ? '◊©◊í◊ô◊ê◊î ◊ë◊ô◊¶◊ô◊®◊™ ◊û◊©◊™◊û◊©:' :
                      this.currentLanguage === 'ru' ? '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:' :
                       'Error creating user:';
      console.error(errorMsg, error);
      alert(errorMsg + ' ' + error.message);
    }
  }
  
  selectUser(userId) {
    if (!userId) {
      console.error('User ID is required');
      return;
    }
    
    this.currentUser = this.users.find(user => user && user.id === userId);
    if (this.currentUser && this.currentUser.id) {
      this.currentDifficulty = this.currentUser.difficultyPreference || 'easy';
      this.saveToStorage(); // Save last active user
      this.showScreen('dashboard');
      console.log('‚úÖ User selected successfully:', this.currentUser.name);
    } else {
      console.error('‚ùå User not found or invalid:', userId);
      const errorMsg = this.currentLanguage === 'he' ? '◊û◊©◊™◊û◊© ◊ú◊ê ◊†◊û◊¶◊ê' :
                      this.currentLanguage === 'ru' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' :
                      'User not found';
      alert(errorMsg);
    }
  }
  
  selectDifficulty(difficulty) {
    this.currentDifficulty = difficulty;
    if (this.currentUser) {
      this.currentUser.difficultyPreference = difficulty;
      this.saveToStorage(); // Save difficulty change
    }
    
    // Update UI
    this.updateDifficultyDisplay();
    this.hideDifficultySelector();
  }
  
  showDifficultySelector() {
    const selector = document.querySelector('.difficulty-selector');
    const currentDisplay = document.querySelector('.current-difficulty-display');
    if (selector && currentDisplay) {
      selector.style.display = 'grid';
      currentDisplay.style.display = 'none';
    }
  }
  
  hideDifficultySelector() {
    const selector = document.querySelector('.difficulty-selector');
    const currentDisplay = document.querySelector('.current-difficulty-display');
    if (selector && currentDisplay) {
      selector.style.display = 'none';
      currentDisplay.style.display = 'flex';
    }
  }
  
  updateDifficultyDisplay() {
    const difficultyConfig = this.difficultyLevels[this.currentDifficulty];
    const difficultyText = this.translate(`difficulty_${this.currentDifficulty}`);
    const difficultyBadge = `${difficultyText} ${difficultyConfig.icon}`;
    
    // Update current difficulty display
    const currentDifficultyText = document.getElementById('current-difficulty-text');
    if (currentDifficultyText) {
      currentDifficultyText.textContent = difficultyBadge;
      currentDifficultyText.className = `difficulty-badge ${this.currentDifficulty}`;
    }
    
    // Update exercise screen difficulty indicator
    const exerciseDifficultyBadge = document.getElementById('exercise-difficulty-badge');
    if (exerciseDifficultyBadge) {
      exerciseDifficultyBadge.textContent = difficultyBadge;
      exerciseDifficultyBadge.className = `difficulty-badge ${this.currentDifficulty}`;
    }
    
    // Update results screen difficulty indicator
    const resultsDifficultyBadge = document.getElementById('results-difficulty-badge');
    if (resultsDifficultyBadge) {
      resultsDifficultyBadge.textContent = difficultyBadge;
      resultsDifficultyBadge.className = `difficulty-badge ${this.currentDifficulty}`;
    }
    
    // Update difficulty selector buttons
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.classList.remove('selected');
      if (btn.dataset.difficulty === this.currentDifficulty) {
        btn.classList.add('selected');
      }
    });
  }
  
  updateDashboard() {
    if (!this.currentUser) return;
    
    // Update user info
    document.getElementById('current-user-avatar').textContent = this.currentUser.avatar;
    const welcomeText = this.currentLanguage === 'he' ? 
      `◊ë◊®◊ï◊ö ◊î◊ë◊ê, ${this.currentUser.name}!` :
      this.currentLanguage === 'ru' ?
      `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, ${this.currentUser.name}!` :
      `Welcome, ${this.currentUser.name}!`;
    document.getElementById('current-user-name').textContent = welcomeText;
    
    // Add expert streak indicator for advanced users
    const streakCard = document.getElementById('streak-card');
    const expertStreakBadge = document.getElementById('expert-streak-badge');
    if (this.currentDifficulty === 'hard' && this.currentUser.stats.currentStreak >= 5) {
      if (streakCard) streakCard.classList.add('hard-focus');
      if (expertStreakBadge) expertStreakBadge.style.display = 'block';
    } else {
      if (streakCard) streakCard.classList.remove('hard-focus');
      if (expertStreakBadge) expertStreakBadge.style.display = 'none';
    }
    
    // Update difficulty system
    this.currentDifficulty = this.currentUser.difficultyPreference || 'easy';
    this.updateDifficultyDisplay();
    this.hideDifficultySelector();
    
    // Update daily progress
    this.updateDailyProgressIfNeeded();
    const todayTotal = this.currentUser.dailyProgress.multiplication + 
                      this.currentUser.dailyProgress.subtraction + 
                      this.currentUser.dailyProgress.division +
                      this.currentUser.dailyProgress.addition;
    const dailyProgressPercent = Math.round((todayTotal / 40) * 100); // 40 total (10 per type)
    document.getElementById('daily-progress').innerHTML = `<span class="progress-text">${dailyProgressPercent}%</span>`;
    
    // Update progress circle with difficulty-specific styling
    const progressCircle = document.getElementById('daily-progress');
    const progressCard = document.getElementById('progress-card');
    const angle = (dailyProgressPercent / 100) * 360;
    
    if (this.currentDifficulty === 'hard') {
      progressCircle.classList.add('hard-level');
      progressCard.classList.add('hard-focus');
      progressCircle.style.background = `conic-gradient(var(--color-difficulty-hard) ${angle}deg, var(--color-bg-4) ${angle}deg)`;
    } else {
      progressCircle.classList.remove('hard-level');
      progressCard.classList.remove('hard-focus');
      progressCircle.style.background = `conic-gradient(var(--color-primary) ${angle}deg, var(--color-bg-1) ${angle}deg)`;
    }
    
    // Update success rate
    const successRate = this.currentUser.stats.totalExercises > 0 
      ? Math.round((this.currentUser.stats.totalCorrect / this.currentUser.stats.totalExercises) * 100)
      : 0;
    document.getElementById('success-rate').textContent = `${successRate}%`;
    
    // Update streak
    document.getElementById('current-streak').textContent = `${this.currentUser.stats.currentStreak} üî•`;
    
    // Update exercise progress with proper translations
    const todayText = this.currentLanguage === 'he' ? '◊î◊ô◊ï◊ù' :
                     this.currentLanguage === 'ru' ? '—Å◊ï–≥–æ–¥–Ω—è' :
                     'today';
    
    document.getElementById('mult-progress').textContent = `${this.currentUser.dailyProgress.multiplication}/10 ${todayText}`;
    document.getElementById('sub-progress').textContent = `${this.currentUser.dailyProgress.subtraction}/10 ${todayText}`;
    document.getElementById('div-progress').textContent = `${this.currentUser.dailyProgress.division}/10 ${todayText}`;
    document.getElementById('add-progress').textContent = `${this.currentUser.dailyProgress.addition}/10 ${todayText}`;
    
    // Update achievements
    this.renderAchievements();
  }
  
  updateDailyProgressIfNeeded() {
    const today = this.getTodayString();
    if (this.currentUser.dailyProgress.date !== today) {
      // Reset daily progress for new day
      this.currentUser.dailyProgress = {
        date: today,
        multiplication: 0,
        subtraction: 0,
        division: 0,
        addition: 0
      };
      
      // Increment days practiced counter
      if (this.currentUser.stats.lastPracticeDate !== today) {
        this.currentUser.stats.daysPracticed++;
      }
      
      // Save the daily progress reset
      this.saveToStorage();
    }
  }
  
  renderAchievements() {
    const container = document.getElementById('achievements-list');
    container.innerHTML = '';
    
    Object.keys(this.achievements).forEach(achievementId => {
      const achievement = this.achievements[achievementId];
      const achievementCard = document.createElement('div');
      achievementCard.className = 'achievement-card';
      
      const isEarned = this.currentUser.achievements.includes(achievementId);
      if (isEarned) {
        achievementCard.classList.add('earned');
      }
      
      const localized = achievement[this.currentLanguage];
      achievementCard.innerHTML = `
        <div class="achievement-icon">${achievement.icon}</div>
        <div class="achievement-name">${localized.name}</div>
        <div class="achievement-description">${localized.description}</div>
      `;
      
      container.appendChild(achievementCard);
    });
  }
  
  startExercise(type) {
    this.updateDailyProgressIfNeeded();
    
    // Check if daily limit reached
    if (this.currentUser.dailyProgress[type] >= 10) {
      const completedMsg = `${this.translate('completed_all')} ${this.translate(type).toLowerCase()} ${this.translate('exercises_for_today')}`;
      alert(completedMsg);
      return;
    }
    
    // Save state before starting exercise
    this.saveToStorage();
    
    this.currentExercise = {
      type: type,
      questions: this.generateQuestions(type, 10),
      currentQuestion: 0,
      answers: [],
      startTime: new Date()
    };
    
    document.getElementById('exercise-title').textContent = this.translate(type);
    document.getElementById('total-questions').textContent = '10';
    
    this.showScreen('exercise');
    this.displayCurrentQuestion();
  }
  
  generateQuestions(type, count) {
    const questions = [];
    const typeConfig = this.exerciseTypes[type];
    const difficultyConfig = this.difficultyLevels[this.currentDifficulty][type];
    
    for (let i = 0; i < count; i++) {
      let question;
      
      if (type === 'multiplication') {
        const a = this.randomInt(difficultyConfig.min_factor1, difficultyConfig.max_factor1);
        const b = this.randomInt(difficultyConfig.min_factor2, difficultyConfig.max_factor2);
        const answer = a * b;
        question = {
          text: `${this.formatNumber(a)} ${typeConfig.symbol} ${this.formatNumber(b)} = ?`,
          answer: answer,
          operands: [a, b],
          difficulty: this.currentDifficulty
        };
      } else if (type === 'subtraction') {
        let minuend, subtrahend, result;
        
        if (this.currentDifficulty === 'easy') {
          // For easy, ensure positive results
          subtrahend = this.randomInt(difficultyConfig.min_subtrahend, difficultyConfig.max_subtrahend);
          result = this.randomInt(0, difficultyConfig.max_minuend - subtrahend);
          minuend = result + subtrahend;
        } else if (this.currentDifficulty === 'hard') {
          // For hard, ensure challenging multi-digit problems with positive results
          minuend = this.randomInt(difficultyConfig.min_minuend, difficultyConfig.max_minuend);
          subtrahend = this.randomInt(difficultyConfig.min_subtrahend, Math.min(difficultyConfig.max_subtrahend, minuend - 1));
          result = minuend - subtrahend;
        } else {
          // For medium, generate within ranges ensuring positive results
          minuend = this.randomInt(difficultyConfig.min_minuend, difficultyConfig.max_minuend);
          subtrahend = this.randomInt(difficultyConfig.min_subtrahend, Math.min(difficultyConfig.max_subtrahend, minuend));
          result = minuend - subtrahend;
        }
        
        question = {
          text: `${this.formatNumber(minuend)} ${typeConfig.symbol} ${this.formatNumber(subtrahend)} = ?`,
          answer: result,
          operands: [minuend, subtrahend],
          difficulty: this.currentDifficulty
        };
      } else if (type === 'division') {
        let dividend, divisor, quotient;
        
        if (this.currentDifficulty === 'easy') {
          // Use predefined easy division problems
          dividend = difficultyConfig.dividends[this.randomInt(0, difficultyConfig.dividends.length - 1)];
          const possibleDivisors = difficultyConfig.divisors.filter(d => dividend % d === 0);
          divisor = possibleDivisors[this.randomInt(0, possibleDivisors.length - 1)];
          quotient = dividend / divisor;
        } else if (this.currentDifficulty === 'hard') {
          // Use pre-generated hard division problems to ensure exact results
          const problemIndex = this.randomInt(0, this.hardDivisionProblems.length - 1);
          const problem = this.hardDivisionProblems[problemIndex];
          dividend = problem[0];
          divisor = problem[1];
          quotient = problem[2];
        } else {
          // Generate medium division problems that result in whole numbers
          divisor = this.randomInt(difficultyConfig.min_divisor, difficultyConfig.max_divisor);
          quotient = this.randomInt(1, Math.floor(difficultyConfig.max_dividend / divisor));
          dividend = divisor * quotient;
        }
        
        question = {
          text: `${this.formatNumber(dividend)} ${typeConfig.symbol} ${this.formatNumber(divisor)} = ?`,
          answer: quotient,
          operands: [dividend, divisor],
          difficulty: this.currentDifficulty
        };
      } else if (type === 'addition') {
        const a = this.randomInt(difficultyConfig.min_addend1, difficultyConfig.max_addend1);
        const b = this.randomInt(difficultyConfig.min_addend2, difficultyConfig.max_addend2);
        const answer = a + b;
        question = {
          text: `${this.formatNumber(a)} ${typeConfig.symbol} ${this.formatNumber(b)} = ?`,
          answer: answer,
          operands: [a, b],
          difficulty: this.currentDifficulty
        };
      }
      
      questions.push(question);
    }
    
    return questions;
  }
  
  displayCurrentQuestion() {
    const question = this.currentExercise.questions[this.currentExercise.currentQuestion];
    
    document.getElementById('math-problem').textContent = question.text;
    document.getElementById('current-question').textContent = this.currentExercise.currentQuestion + 1;
    document.getElementById('answer-input').value = '';
    document.getElementById('answer-input').focus();
    
    // Display appropriate question instruction based on exercise type
    const questionInstruction = document.querySelector('.question-instruction');
    if (questionInstruction) {
      const instructionKey = this.currentExercise.type === 'addition' ? 'solve_addition_problem' : 'solve_problem';
      questionInstruction.textContent = this.translate(instructionKey);
    }
    
    // Show time indicator for hard problems
    const timeIndicator = document.getElementById('time-indicator');
    if (this.currentDifficulty === 'hard') {
      timeIndicator.style.display = 'block';
      timeIndicator.classList.add('hard-time');
      this.startQuestionTimer();
    } else {
      timeIndicator.style.display = 'none';
    }
    
    // Update progress bar
    const progressPercent = ((this.currentExercise.currentQuestion) / this.currentExercise.questions.length) * 100;
    document.getElementById('exercise-progress-fill').style.width = `${progressPercent}%`;
    
    // Hide feedback
    document.getElementById('feedback').classList.add('hidden');
  }
  
  startQuestionTimer() {
    // Give more time for hard problems: 90 seconds
    let timeLeft = 90;
    const timeDisplay = document.getElementById('time-remaining');
    
    const timer = setInterval(() => {
      timeLeft--;
      if (timeDisplay) {
        timeDisplay.textContent = timeLeft;
        
        // Change color when time is running low
        const timeIndicator = document.getElementById('time-indicator');
        if (timeLeft <= 20) {
          timeIndicator.style.background = 'var(--color-bg-4)';
          timeIndicator.style.color = 'var(--color-error)';
          timeIndicator.style.borderColor = 'var(--color-error)';
        }
      }
      
      if (timeLeft <= 0) {
        clearInterval(timer);
        this.handleTimeOut();
      }
    }, 1000);
    
    // Store timer to clear it when question changes
    if (this.questionTimer) {
      clearInterval(this.questionTimer);
    }
    this.questionTimer = timer;
  }
  
  handleTimeOut() {
    const timeUpMessage = this.currentLanguage === 'he' ? 
      '‚è∞ ◊î◊ñ◊û◊ü ◊†◊í◊û◊®! ◊ë◊ï◊ê◊ï ◊†◊†◊°◊î ◊ê◊™ ◊î◊©◊ê◊ú◊î ◊î◊ë◊ê◊î.' :
      this.currentLanguage === 'ru' ?
      '‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! –ü–æ–ø—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å.' :
      '‚è∞ Time\'s up! Let\'s try the next question.';
      
    alert(timeUpMessage);
    this.nextQuestion();
  }
  
  submitAnswer() {
    const input = document.getElementById('answer-input');
    const userAnswer = parseInt(input.value);
    const question = this.currentExercise.questions[this.currentExercise.currentQuestion];
    
    if (isNaN(userAnswer)) {
      const enterNumberText = this.currentLanguage === 'he' ? 
        '◊ê◊†◊ê ◊î◊õ◊†◊° ◊û◊°◊§◊®!' :
        this.currentLanguage === 'ru' ?
        '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!' :
        'Please enter a number!';
      alert(enterNumberText);
      return;
    }
    
    const isCorrect = userAnswer === question.answer;
    
    this.currentExercise.answers.push({
      question: question,
      userAnswer: userAnswer,
      correct: isCorrect,
      timestamp: new Date()
    });
    
    this.showFeedback(isCorrect, question.answer);
  }
  
  showFeedback(isCorrect, correctAnswer) {
    const feedback = document.getElementById('feedback');
    const message = document.getElementById('feedback-message');
    
    // Clear question timer if exists
    if (this.questionTimer) {
      clearInterval(this.questionTimer);
    }
    
    feedback.classList.remove('hidden', 'correct', 'incorrect', 'hard-level');
    
    if (isCorrect) {
      feedback.classList.add('correct');
      message.textContent = this.getDifficultyBasedMessage('correct');
      feedback.classList.add('bounce');
      
      // Special celebration for hard problems
      if (this.currentDifficulty === 'hard') {
        feedback.classList.add('hard-level');
        this.showCelebrationEffect();
      }
    } else {
      feedback.classList.add('incorrect');
      const formattedAnswer = this.formatNumber(correctAnswer);
      const correctAnswerText = this.currentLanguage === 'he' ? 
        `${this.getDifficultyBasedMessage('incorrect')} ◊î◊™◊©◊ï◊ë◊î ◊î◊†◊õ◊ï◊†◊î ◊î◊ô◊ê ${formattedAnswer}.` :
        this.currentLanguage === 'ru' ?
        `${this.getDifficultyBasedMessage('incorrect')} –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${formattedAnswer}.` :
        `${this.getDifficultyBasedMessage('incorrect')} The correct answer is ${formattedAnswer}.`;
      message.textContent = correctAnswerText;
      feedback.classList.add('shake');
      
      if (this.currentDifficulty === 'hard') {
        feedback.classList.add('hard-level');
      }
    }
    
    setTimeout(() => {
      feedback.classList.remove('bounce', 'shake');
    }, 1000);
  }
  
  showCelebrationEffect() {
    const celebrationEl = document.getElementById('celebration-effect');
    if (celebrationEl) {
      const celebrations = ['üéâ', '‚≠ê', 'üèÜ', 'üí´', 'üåü', 'üéä'];
      const randomCelebration = celebrations[Math.floor(Math.random() * celebrations.length)];
      
      celebrationEl.textContent = randomCelebration;
      celebrationEl.style.display = 'block';
      celebrationEl.style.animation = 'none';
      
      setTimeout(() => {
        celebrationEl.style.animation = 'celebrate 2s ease-out';
      }, 10);
      
      setTimeout(() => {
        celebrationEl.style.display = 'none';
      }, 2000);
    }
  }
  
  getDifficultyBasedMessage(type) {
    // For addition exercises, use addition-specific messages if available
    // let messageSource = this.currentExercise.type === 'addition' 
    //   ? this.encouragingMessagesByDifficulty.addition
    //   : this.encouragingMessagesByDifficulty[this.currentDifficulty];
      let messageSource = this.encouragingMessagesByDifficulty[this.currentDifficulty];
    
    const messages = messageSource[type][this.currentLanguage];
    return messages[Math.floor(Math.random() * messages.length)];
  }
  
  nextQuestion() {
    // Clear any existing timer
    if (this.questionTimer) {
      clearInterval(this.questionTimer);
    }
    
    this.currentExercise.currentQuestion++;
    
    if (this.currentExercise.currentQuestion >= this.currentExercise.questions.length) {
      this.finishExercise();
    } else {
      this.displayCurrentQuestion();
    }
  }
  
  finishExercise() {
    const correctAnswers = this.currentExercise.answers.filter(a => a.correct).length;
    const totalQuestions = this.currentExercise.answers.length;
    const scorePercent = Math.round((correctAnswers / totalQuestions) * 100);
    
    // Update user stats
    this.currentUser.stats.totalExercises += totalQuestions;
    this.currentUser.stats.totalCorrect += correctAnswers;
    this.currentUser.exerciseStats[this.currentExercise.type].total += totalQuestions;
    this.currentUser.exerciseStats[this.currentExercise.type].correct += correctAnswers;
    this.currentUser.dailyProgress[this.currentExercise.type] += totalQuestions;
    
    // Update difficulty-specific stats
    if (!this.currentUser.difficultyStats) {
      this.currentUser.difficultyStats = {
        easy: { total: 0, correct: 0 },
        medium: { total: 0, correct: 0 },
        hard: { total: 0, correct: 0 }
      };
    }
    this.currentUser.difficultyStats[this.currentDifficulty].total += totalQuestions;
    this.currentUser.difficultyStats[this.currentDifficulty].correct += correctAnswers;
    
    // Add exercise history entry
    if (!this.currentUser.exerciseHistory) {
      this.currentUser.exerciseHistory = [];
    }
    
    this.currentExercise.answers.forEach((answer, index) => {
      this.currentUser.exerciseHistory.push({
        date: new Date().toISOString(),
        operation: this.currentExercise.type,
        difficulty: this.currentDifficulty,
        problem: answer.question.text,
        userAnswer: answer.userAnswer,
        correctAnswer: answer.question.answer,
        isCorrect: answer.correct,
        timeSpent: answer.timestamp - this.currentExercise.startTime
      });
    });
    
    // Keep only last 1000 exercise history entries for performance
    if (this.currentUser.exerciseHistory.length > 1000) {
      this.currentUser.exerciseHistory = this.currentUser.exerciseHistory.slice(-1000);
    }
    
    // Update streak and practice date
    const today = this.getTodayString();
    const lastPractice = this.currentUser.stats.lastPracticeDate;
    
    if (lastPractice === today) {
      // Already practiced today, no streak change
    } else if (this.isConsecutiveDay(lastPractice, today)) {
      this.currentUser.stats.currentStreak++;
    } else {
      this.currentUser.stats.currentStreak = 1;
    }
    
    this.currentUser.stats.lastPracticeDate = today;
    this.currentUser.stats.bestStreak = Math.max(this.currentUser.stats.bestStreak, this.currentUser.stats.currentStreak);
    
    // Update days practiced if this is a new day
    const uniquePracticeDates = new Set();
    if (this.currentUser.exerciseHistory) {
      this.currentUser.exerciseHistory.forEach(exercise => {
        uniquePracticeDates.add(exercise.date.split('T')[0]);
      });
    }
    uniquePracticeDates.add(today);
    this.currentUser.stats.daysPracticed = uniquePracticeDates.size;
    
    // Check achievements
    const newAchievements = this.checkAchievements();
    
    // Save all progress immediately after exercise completion
    this.saveToStorage();
    
    // Show achievement notifications
    if (newAchievements.length > 0) {
      this.showAchievementNotifications(newAchievements);
    }
    
    // Show results
    this.showResults(correctAnswers, totalQuestions - correctAnswers, scorePercent);
    
    // Check for difficulty progression suggestions
    this.checkDifficultyProgression(scorePercent);
  }
  
  checkAchievements() {
    const user = this.currentUser;
    const newAchievements = [];
    
    // First Steps - Complete first exercise
    if (user.stats.totalExercises > 0 && !user.achievements.includes('first_steps')) {
      user.achievements.push('first_steps');
      newAchievements.push('first_steps');
    }
    
    // Perfect Score - Get 100%
    const lastExerciseCorrect = this.currentExercise.answers.filter(a => a.correct).length;
    const lastExerciseTotal = this.currentExercise.answers.length;
    if (lastExerciseCorrect === lastExerciseTotal && !user.achievements.includes('perfect_score')) {
      user.achievements.push('perfect_score');
      newAchievements.push('perfect_score');
    }
    
    // Daily Warrior - Complete all daily exercises (40 total)
    const todayTotal = user.dailyProgress.multiplication + user.dailyProgress.subtraction + user.dailyProgress.division + user.dailyProgress.addition;
    if (todayTotal >= 40 && !user.achievements.includes('daily_warrior')) {
      user.achievements.push('daily_warrior');
      newAchievements.push('daily_warrior');
    }
    
    // Week Streak - 7 days in a row
    if (user.stats.currentStreak >= 7 && !user.achievements.includes('week_streak')) {
      user.achievements.push('week_streak');
      newAchievements.push('week_streak');
    }
    
    // Difficulty-specific mastery achievements
    ['easy', 'medium', 'hard'].forEach(difficulty => {
      const achievementKey = `${difficulty}_master`;
      if (!user.achievements.includes(achievementKey)) {
        const diffStats = user.difficultyStats[difficulty];
        const accuracy = diffStats.total > 0 ? (diffStats.correct / diffStats.total) * 100 : 0;
        if (diffStats.total >= 50 && accuracy >= 90) {
          user.achievements.push(achievementKey);
          newAchievements.push(achievementKey);
        }
      }
    });
    
    // Addition-specific achievements
    const addStats = user.exerciseStats.addition;
    if (addStats.total >= 10 && !user.achievements.includes('addition_beginner')) {
      user.achievements.push('addition_beginner');
      newAchievements.push('addition_beginner');
    }
    
    if (addStats.total >= 50 && !user.achievements.includes('addition_expert')) {
      const addAccuracy = (addStats.correct / addStats.total) * 100;
      if (addAccuracy >= 80) {
        user.achievements.push('addition_expert');
        newAchievements.push('addition_expert');
      }
    }
    
    return newAchievements;
  }
  
  showAchievementNotifications(achievements) {
    achievements.forEach((achievementId, index) => {
      setTimeout(() => {
        this.showSingleAchievementNotification(achievementId);
      }, index * 1000); // Stagger notifications
    });
  }
  
  showSingleAchievementNotification(achievementId) {
    const achievement = this.achievements[achievementId];
    if (!achievement) return;
    
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      background: linear-gradient(135deg, var(--color-warning) 0%, var(--color-primary) 100%);
      color: white;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      z-index: 1001;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      max-width: 280px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    `;
    
    const localized = achievement[this.currentLanguage];
    const unlockedText = this.currentLanguage === 'he' ? 'üèÜ ◊î◊ô◊©◊í ◊ó◊ì◊©!' :
                        this.currentLanguage === 'ru' ? 'üèÜ –ù–æ–≤–æ◊ï –¥–æ—Å—Ç–∏–∂◊ï–Ω–∏◊ï!' :
                        'üèÜ Achievement Unlocked!';
    
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 4px; font-size: 14px;">${unlockedText}</div>
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 20px;">${achievement.icon}</span>
        <div>
          <div style="font-weight: bold; font-size: 13px;">${localized.name}</div>
          <div style="font-size: 11px; opacity: 0.9;">${localized.description}</div>
        </div>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.transform = 'translateX(0)';
    }, 100);
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      notification.style.transform = 'translateX(100%)';
      setTimeout(() => document.body.removeChild(notification), 300);
    });
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 300);
      }
    }, 5000);
  }
  
  showResults(correct, incorrect, scorePercent) {
    document.getElementById('correct-count').textContent = correct;
    document.getElementById('incorrect-count').textContent = incorrect;
    document.getElementById('final-score').textContent = `${scorePercent}%`;
    
    // Update difficulty-specific results display
    this.updateDifficultyDisplay();
    
    // Show expert achievement notice for hard level
    const expertNotice = document.getElementById('expert-achievement-notice');
    if (this.currentDifficulty === 'hard' && scorePercent >= 70) {
      if (expertNotice) {
        expertNotice.style.display = 'flex';
        expertNotice.innerHTML = `
          <span>üèÜ ${this.translate('expert_level')}</span>
        `;
      }
    } else if (expertNotice) {
      expertNotice.style.display = 'none';
    }
    
    // Update difficulty progress bar
    const progressFill = document.getElementById('difficulty-progress-fill');
    if (progressFill) {
      const progressWidth = this.currentDifficulty === 'easy' ? 33 : 
                           this.currentDifficulty === 'medium' ? 66 : 100;
      progressFill.style.width = `${progressWidth}%`;
    }
    
    // Set emoji based on performance
    let emoji = 'üéâ';
    if (scorePercent === 100) emoji = 'üèÜ';
    else if (scorePercent >= 80) emoji = 'üåü';
    else if (scorePercent >= 60) emoji = 'üëç';
    else emoji = 'üí™';
    
    document.getElementById('results-emoji').textContent = emoji;
    
    // Set difficulty-specific encouragement message
    let encouragement = this.getDifficultySpecificEncouragement(scorePercent);
    document.getElementById('encouragement-message').textContent = encouragement;
    
    this.showScreen('results');
  }
  
  getDifficultySpecificEncouragement(scorePercent) {
    const difficultyKey = `good_job_${this.currentDifficulty}`;
    
    if (scorePercent === 100) {
      return this.translate(difficultyKey) + ' ' + (this.currentLanguage === 'he' ? 'üèÜ' :
        this.currentLanguage === 'ru' ? 'üèÜ' : 'üèÜ');
    } else if (scorePercent >= 80) {
      return this.translate(difficultyKey);
    } else if (scorePercent >= 60) {
      const practiceMsg = this.currentLanguage === 'he' ? 
        '◊î◊û◊©◊ö ◊ú◊î◊™◊ê◊û◊ü ◊ï◊™◊©◊™◊§◊®!' :
        this.currentLanguage === 'ru' ?
        '–ü—Ä–æ–¥–æ–ª–∂–∞–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏ —Ç—ã —É–ª—É—á—à–∏—à—å—Å—è!' :
        'Keep practicing and you\'ll improve!';
      return practiceMsg + ' üìà';
    } else {
      const effortMsg = this.currentLanguage === 'he' ? 
        '◊û◊ê◊û◊• ◊†◊î◊ì◊®! ◊õ◊ú ◊ò◊¢◊ï◊™ ◊û◊ú◊û◊ì◊™ ◊ê◊ï◊™◊†◊ï!' :
        this.currentLanguage === 'ru' ?
        '–û—Ç–ª–∏—á–Ω—ã–µ —É—Å–∏–ª–∏—è! –ö–∞–∂–¥–∞—è –æ—à–∏–±–∫–∞ –Ω–∞—Å —É—á–∏—Ç!' :
        'Great effort! Every mistake teaches us something!';
      return effortMsg + ' üí™';
    }
  }
  
  checkDifficultyProgression(scorePercent) {
    const progressMsg = document.getElementById('difficulty-progress-message');
    if (!progressMsg) return;
    
    const difficultyStats = this.currentUser.difficultyStats[this.currentDifficulty];
    const accuracy = difficultyStats.total > 0 ? (difficultyStats.correct / difficultyStats.total) * 100 : 0;
    
    let message = '';
    
    if (this.currentDifficulty === 'easy' && accuracy >= 85 && difficultyStats.total >= 20) {
      message = this.translate('try_harder');
    } else if (this.currentDifficulty === 'medium' && accuracy >= 85 && difficultyStats.total >= 20) {
      message = this.translate('try_harder');
    } else if (this.currentDifficulty === 'hard' && accuracy >= 70 && difficultyStats.total >= 25) {
      // Different mastery criteria for hard level (70% instead of 90%)
      message = this.translate('expert_level');
    } else if (accuracy >= 90 && difficultyStats.total >= 50) {
      message = this.translate('mastered');
    }
    
    progressMsg.textContent = message;
  }
  
  retryExercise() {
    this.startExercise(this.currentExercise.type);
  }
  
  updateProgressScreen() {
    if (!this.currentUser) return;
    
    const user = this.currentUser;
    
    // Update overall statistics
    document.getElementById('total-exercises').textContent = user.stats.totalExercises;
    document.getElementById('total-correct').textContent = user.stats.totalCorrect;
    document.getElementById('best-streak').textContent = user.stats.bestStreak;
    document.getElementById('days-practiced').textContent = user.stats.daysPracticed;
    
    // Update exercise type breakdown
    const multAccuracy = user.exerciseStats.multiplication.total > 0 
      ? Math.round((user.exerciseStats.multiplication.correct / user.exerciseStats.multiplication.total) * 100)
      : 0;
    const subAccuracy = user.exerciseStats.subtraction.total > 0 
      ? Math.round((user.exerciseStats.subtraction.correct / user.exerciseStats.subtraction.total) * 100)
      : 0;
    const divAccuracy = user.exerciseStats.division.total > 0 
      ? Math.round((user.exerciseStats.division.correct / user.exerciseStats.division.total) * 100)
      : 0;
    const addAccuracy = user.exerciseStats.addition.total > 0 
      ? Math.round((user.exerciseStats.addition.correct / user.exerciseStats.addition.total) * 100)
      : 0;
    
    document.getElementById('mult-accuracy').textContent = `${multAccuracy}%`;
    document.getElementById('mult-total').textContent = user.exerciseStats.multiplication.total;
    
    document.getElementById('sub-accuracy').textContent = `${subAccuracy}%`;
    document.getElementById('sub-total').textContent = user.exerciseStats.subtraction.total;
    
    document.getElementById('div-accuracy').textContent = `${divAccuracy}%`;
    document.getElementById('div-total').textContent = user.exerciseStats.division.total;
    
    document.getElementById('add-accuracy').textContent = `${addAccuracy}%`;
    document.getElementById('add-total').textContent = user.exerciseStats.addition.total;
  }
  
  downloadApp() {
    // Create a downloadable HTML file containing the entire application
    const htmlContent = this.generateDownloadableHTML();
    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'math-learning-app.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  generateDownloadableHTML() {
    // Get current HTML structure
    const currentHTML = document.documentElement.outerHTML;
    
    // Create a complete standalone HTML file
    return `<!DOCTYPE html>
<html lang="${this.currentLanguage}" dir="${this.languages[this.currentLanguage].direction}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.translate('app_title')}</title>
    <style>
        ${this.getInlineCSS()}
    </style>
</head>
<body>
    ${document.body.innerHTML}
    <script>
        ${this.getInlineJS()}
    </script>
</body>
</html>`;
  }
  
  getInlineCSS() {
    // Get CSS from the current stylesheet
    let css = '';
    for (const sheet of document.styleSheets) {
      try {
        for (const rule of sheet.cssRules) {
          css += rule.cssText + '\n';
        }
      } catch (e) {
        // Handle CORS issues with external stylesheets
        console.log('Cannot access stylesheet:', e);
      }
    }
    return css;
  }
  
  getInlineJS() {
    // Return a simplified version of the app code
    return `
    // Math Learning App - Standalone Version
    // This is a simplified version for offline use
    console.log('Math Learning App loaded successfully!');
    
    // Create a message for offline use
    const offlineMessage = document.createElement('div');
    offlineMessage.style.cssText = 'position: fixed; top: 10px; right: 10px; background: #4CAF50; color: white; padding: 10px; border-radius: 5px; z-index: 1000;';
    offlineMessage.textContent = 'App downloaded successfully! This is an offline version.';
    document.body.appendChild(offlineMessage);
    
    setTimeout(() => {
      offlineMessage.remove();
    }, 5000);
    `;
  }
  
  // Number formatting function
  formatNumber(num) {
    if (this.currentDifficulty === 'hard' && num >= 1000) {
      return num.toLocaleString();
    }
    return num.toString();
  }
  
  // Utility functions
  randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  getTodayString() {
    return new Date().toISOString().split('T')[0];
  }
  
  isConsecutiveDay(lastDate, currentDate) {
    if (!lastDate) return false;
    
    const last = new Date(lastDate);
    const current = new Date(currentDate);
    const diffTime = current - last;
    const diffDays = diffTime / (1000 * 60 * 60 * 24);
    
    return diffDays === 1;
  }
  
  // ===============================================
  // STORAGE SIMULATION METHODS
  // ===============================================
  // These methods simulate persistent storage functionality using in-memory storage
  // since browser storage APIs are blocked in the sandboxed environment
  
  saveToStorage() {
    console.log('Saving data to storage...');
    
    // Debounce saves to prevent performance issues
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    this.saveTimeout = setTimeout(() => {
      try {
        // Validate users array before processing
        const validatedUsers = (this.users || []).map(user => {
          // Ensure user object exists and has all required properties
          if (!user) {
            console.warn('‚ö†Ô∏è Null user found, skipping');
            return null;
          }
          
          return {
            id: user.id || Date.now().toString() + Math.random().toString(36).substr(2, 9),
            name: user.name || '',
            avatar: user.avatar || 'üê±',
            createdDate: user.createdDate || user.createdAt?.toISOString?.() || new Date().toISOString(),
            language: user.language || 'he',
            currentDifficulty: user.currentDifficulty || user.difficultyPreference || 'easy',
            statistics: {
              totalExercises: user.stats?.totalExercises || 0,
              correctAnswers: user.stats?.totalCorrect || 0,
              totalScore: user.stats?.totalCorrect || 0,
              streakDays: user.stats?.currentStreak || 0,
              lastActiveDate: user.stats?.lastPracticeDate || new Date().toISOString().split('T')[0],
              averageTimePerExercise: this.calculateAverageTime(user)
            },
            exerciseHistory: user.exerciseHistory || [],
            dailyProgress: this.formatDailyProgress(user.dailyProgress),
            achievements: (user.achievements || []).map(achievementId => ({
              id: achievementId,
              unlockedDate: new Date().toISOString().split('T')[0],
              progress: 100
            })),
            preferences: {
              difficulty: user.difficultyPreference || user.currentDifficulty || 'easy',
              language: user.language || this.currentLanguage,
              soundEnabled: true,
              theme: 'default'
            }
          };
        }).filter(user => user !== null); // Remove null entries
        
        const dataToSave = {
          users: validatedUsers,
          appSettings: {
            lastActiveUser: this.currentUser && this.currentUser.id ? this.currentUser.id : null,
            defaultLanguage: this.currentLanguage
          }
        };
        
        // Store data in memory (simulating persistent storage)
        this.storageData.mathApp_userData = JSON.stringify(dataToSave);
        this.storageData.mathApp_settings = JSON.stringify({
          language: this.currentLanguage,
          lastSaveDate: new Date().toISOString()
        });
        
        console.log('‚úÖ Data saved successfully to simulated storage');
        console.log('Saved users:', validatedUsers.length);
        this.showDataSavedIndicator();
        
      } catch (error) {
        console.error('‚ö†Ô∏è Error saving data:', error);
        const errorMsg = this.currentLanguage === 'he' ? '◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊™ ◊†◊™◊ï◊†◊ô◊ù' :
                        this.currentLanguage === 'ru' ? '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö' :
                        'Data saving error';
        alert(errorMsg + ': ' + error.message);
        this.handleStorageError(error);
      }
    }, this.saveDebounceMs);
  }
  
  getFromStorage(key) {
    try {
      console.log('Reading from storage:', key);
      
      if (!key || !this.storageData) {
        console.warn('‚ö†Ô∏è Invalid key or storage data');
        return null;
      }
      
      // Retrieve from in-memory storage simulation
      const data = this.storageData[key];
      const result = data ? JSON.parse(data) : null;
      console.log('Retrieved from storage:', result ? 'data found' : 'no data');
      return result;
    } catch (error) {
      console.error('‚ö†Ô∏è Error reading from storage:', error);
      const errorMsg = this.currentLanguage === 'he' ? '◊©◊í◊ô◊ê◊î ◊ë◊ò◊¢◊ô◊†◊™ ◊†◊™◊ï◊†◊ô◊ù' :
                      this.currentLanguage === 'ru' ? '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö' :
                       'Data loading error';
      console.error(errorMsg + ':', error);
      return null;
    }
  }
  
  calculateAverageTime(user) {
    if (!user || !user.exerciseHistory || user.exerciseHistory.length === 0) return 0;
    const totalTime = user.exerciseHistory.reduce((sum, exercise) => {
      return sum + (exercise && exercise.timeSpent ? exercise.timeSpent : 0);
    }, 0);
    return Math.round(totalTime / user.exerciseHistory.length);
  }
  
  formatDailyProgress(progress) {
    const today = this.getTodayString();
    return {
      [today]: {
        multiplication: { completed: progress?.multiplication || 0, correct: progress?.multiplication || 0 },
        addition: { completed: progress?.addition || 0, correct: progress?.addition || 0 },
        subtraction: { completed: progress?.subtraction || 0, correct: progress?.subtraction || 0 },
        division: { completed: progress?.division || 0, correct: progress?.division || 0 }
      }
    };
  }

  
  validateAndCleanupData() {
    // Validate and clean up user data structure
    this.users = (this.users || []).filter(user => {
      if (!user || !user.id || !user.name) {
        console.warn('‚ö†Ô∏è Invalid user found, removing:', user);
        return false;
      }
      
      // Ensure createdDate exists (fix createdAt vs createdDate inconsistency)
      if (!user.createdDate) {
        user.createdDate = user.createdAt?.toISOString?.() || new Date().toISOString();
      }
      
      // Ensure required properties exist
      if (!user.stats) {
        user.stats = {
          totalExercises: 0,
          totalCorrect: 0,
          currentStreak: 0,
          bestStreak: 0,
          daysPracticed: 0,
          lastPracticeDate: null
        };
      }
      
      if (!user.exerciseStats) {
        user.exerciseStats = {
          multiplication: { total: 0, correct: 0 },
          subtraction: { total: 0, correct: 0 },
          division: { total: 0, correct: 0 },
          addition: { total: 0, correct: 0 }
        };
      }
      
      if (!user.dailyProgress) {
        user.dailyProgress = {
          date: this.getTodayString(),
          multiplication: 0,
          subtraction: 0,
          division: 0,
          addition: 0
        };
      }
      
      if (!user.achievements) {
        user.achievements = [];
      }
      
      if (!user.difficultyStats) {
        user.difficultyStats = {
          easy: { total: 0, correct: 0 },
          medium: { total: 0, correct: 0 },
          hard: { total: 0, correct: 0 }
        };
      }
      
      if (!user.exerciseHistory) {
        user.exerciseHistory = [];
      }
      
      // Ensure language and difficulty preferences exist
      if (!user.language) {
        user.language = this.currentLanguage || 'he';
      }
      
      if (!user.difficultyPreference && !user.currentDifficulty) {
        user.difficultyPreference = 'easy';
        user.currentDifficulty = 'easy';
      }
      
      return true;
    });
    
    console.log(`‚úÖ Validated ${this.users.length} users with proper data structures`);
  }
  
  handleStorageError(error) {
    const errorMessage = this.currentLanguage === 'he' ? 
      '‚ö†Ô∏è ◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊™ ◊î◊†◊™◊ï◊†◊ô◊ù' :
      this.currentLanguage === 'ru' ?
      '‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö' :
      '‚ö†Ô∏è Data saving error';
      
    console.warn(errorMessage, error);
  }
  
  showDataSavedIndicator() {
    try {
      // Create a subtle indicator that data was saved
      const indicator = document.createElement('div');
      indicator.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--color-success);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      `;
      
      const saveMessage = this.currentLanguage === 'he' ? 
        '‚úÖ ◊†◊™◊ï◊†◊ô◊ù ◊†◊©◊û◊®◊ï ◊ë◊î◊¶◊ú◊ó◊î' :
        this.currentLanguage === 'ru' ?
        '‚úÖ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã' :
        '‚úÖ Data saved successfully';
        
      indicator.textContent = saveMessage;
      document.body.appendChild(indicator);
      
      // Show and hide the indicator
      setTimeout(() => indicator.style.opacity = '1', 100);
      setTimeout(() => {
        if (indicator.parentNode) {
          indicator.style.opacity = '0';
          setTimeout(() => {
            if (indicator.parentNode) {
              document.body.removeChild(indicator);
            }
          }, 300);
        }
      }, 2000);
    } catch (error) {
      console.error('‚ö†Ô∏è Error showing save indicator:', error);
    }
  }
  
  showDataRestoredMessage() {
    // Show welcome back message for returning users
    const welcomeMessage = document.createElement('div');
    welcomeMessage.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--color-bg-1);
      border: 2px solid var(--color-primary);
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      z-index: 1000;
      box-shadow: var(--shadow-lg);
      max-width: 300px;
    `;
    
    const welcomeText = this.currentLanguage === 'he' ? 
      'üéâ ◊ë◊®◊ï◊ö ◊î◊©◊ë!<br>üíæ ◊î◊™◊ß◊ì◊û◊ï◊™◊ö ◊©◊ï◊ó◊ñ◊®◊î' :
      this.currentLanguage === 'ru' ?
      'üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ!<br>üíæ –ü—Ä–æ–≥—Ä–µ—Å—Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' :
      'üéâ Welcome Back!<br>üíæ Progress Restored';
    
    welcomeMessage.innerHTML = `
      <div style="margin-bottom: 16px; font-weight: bold;">${welcomeText}</div>
      <button onclick="this.parentElement.remove()" style="
        background: var(--color-primary);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
      ">OK</button>
    `;
    
    document.body.appendChild(welcomeMessage);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (welcomeMessage.parentNode) {
        welcomeMessage.remove();
      }
    }, 5000);
  }
  
  // Enhanced user creation with full data structure
  createUserWithFullStructure(name, avatar) {
    console.log('Creating user structure for:', name, avatar);
    
    if (!name || !avatar) {
      throw new Error('Name and avatar are required');
    }
    
    const userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();
    const today = this.getTodayString();
    
    const newUser = {
      id: userId,
      name: name,
      avatar: avatar,
      createdDate: now, // Use createdDate consistently, not createdAt
      language: this.currentLanguage,
      currentDifficulty: 'easy',
      statistics: {
        totalExercises: 0,
        correctAnswers: 0,
        totalScore: 0,
        streakDays: 0,
        lastActiveDate: today,
        averageTimePerExercise: 0
      },
      stats: {
        totalExercises: 0,
        totalCorrect: 0,
        currentStreak: 0,
        bestStreak: 0,
        daysPracticed: 0,
        lastPracticeDate: null
      },
      exerciseHistory: [],
      exerciseStats: {
        multiplication: { total: 0, correct: 0 },
        subtraction: { total: 0, correct: 0 },
        division: { total: 0, correct: 0 },
        addition: { total: 0, correct: 0 }
      },
      dailyProgress: {
        date: today,
        multiplication: 0,
        subtraction: 0,
        division: 0,
        addition: 0
      },
      achievements: [],
      difficultyPreference: 'easy',
      difficultyStats: {
        easy: { total: 0, correct: 0 },
        medium: { total: 0, correct: 0 },
        hard: { total: 0, correct: 0 }
      },
      preferences: {
        difficulty: 'easy',
        language: this.currentLanguage,
        soundEnabled: true,
        theme: 'default'
      }
    };
    
    console.log('‚úÖ User structure created successfully:', newUser);
    return newUser;
  }
}

// Initialize the app when the page loads
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM Content Loaded - Starting Math App...');
  
  try {
    window.mathApp = new MathApp();
    console.log('Math App instance created successfully');
  } catch (error) {
    console.error('Fatal error creating Math App:', error);
    
    // Create a simple error display
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #f44336;
      color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      z-index: 9999;
      font-family: Arial, sans-serif;
    `;
    errorDiv.innerHTML = `
      <h3>App Loading Error</h3>
      <p>${error.message}</p>
      <button onclick="location.reload()" style="
        background: white;
        color: #f44336;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      ">Reload Page</button>
    `;
    document.body.appendChild(errorDiv);
  }
});